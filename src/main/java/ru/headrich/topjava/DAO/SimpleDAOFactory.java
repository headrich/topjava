package ru.headrich.topjava.DAO;

/**
 * Created by Montana on 18.06.2016.
 */
public class SimpleDAOFactory {

    private static UserDAO userDAO;
    private static UserMealDAO userMealDAO;
    private static SimpleDAOFactory instance;

    public static SimpleDAOFactory getInstance(){
        if(instance==null){
            synchronized (SimpleDAOFactory.class){
                if(instance==null){
                    instance = new SimpleDAOFactory();
                }
            }
        }
        return instance;
    }

    private SimpleDAOFactory(){};

    //TODO-me два варианта. Первый - орм движок считывает классы сущностей по аннотациям.
    //ну это годно, только вот это будет просто оборачивание классов прокси-декораторами.
    //при этом те объекты, которые мы получаем из базы будут этими проксями.
    // ИЛИ ЖЕ
    //  при иницилизации конкретного ДАО создавать этот следящий прокси..

    // TODO Нужно создать поле оригинального объекта в прокси-объекте.. Чтоб не потерять его.
    // и задать логику сравнения. если это необходимо.
    //TODO второй - как то клепать клоны, но не заранее , так как неизвестно для чего(ПОКА БЕЗ АННОТАЦИЙ/ упрощенный варик),
    // а как бы по необходимости, при вызове соответвующих методов ДАО.. прямо в методе грязным кодом
    //создавать клон полученного объекта.

    //ВОПРОС! А как сделать лучше? Получить данные, сделать клон, работать с клоном. Потом сравнить.
    //тогда нужно где-то хранить оригинал  и клон, чтобы не запутаться и не потерять ничего.
    //наверно в хибернейте этим как раз занимается Session (CurrentSession или OpenSession) ,!!!!!!доп. ХОТЯ  Session по сути является обобщенным ДАО
    //которая хранит в себе информацию текущего запроса

    // или получить данные и записать их сразу в прокси объект?
    // и еще! как быть с данными , которые мы не получали из базы. Т.е мы создали нового опльзователя, или продукт, например,
    // а значит создали новый объект сущности, при этом он вне сессии, он не клон. он оригинал, и как его не потерять и не перепутать с клонами из базы.
    //КАК ЖЕ С НИМ РАБОТАТЬ!? Ну можно сделать так: по сути мы не знаем что удалять, обновить, т.к у на нет id, (с другой стороны это не безопасно), так как
    //омжно слуайно удалить что угодно. Но тем не менее, мы можем сохранить этот чистый внесессионный объект, и тут же его получить обратно, но уже как объект из базы данных.
    // и создать его клон , чтобы в дальнейшем отслеживать его изменения. т.е создаем сессию. ЧТо касатеся операций удаления или обновления. У нас там нет каких-то объектов впринципе,
    //мы просто отправляем запрос на обновление или удаление.

    //Еще вариант применить АОП сквозное программирование и встраивать код записи изменений при вызове сет методов в сущностях

    //Вариант сессию держать всюду, в ней состояние объектов, и при изменении объекта в слое сервиса, пихать изменения в сессию. потом уже генерить запросы на изменения


    private void initializeORMEngine(){

    }

    public UserDAO getUserDAO(){
        if(userDAO==null){
            userDAO= new UserDAOImpl();
        }
        return userDAO;
    }

    public UserMealDAO getUserMealDAO(){
        if(userMealDAO==null){
            userMealDAO=new UserMealDAOImpl();
        }
        return userMealDAO;
    }



}
